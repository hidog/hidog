#include "fraction.h"


namespace	hidog
{
namespace	math
{





/************************************************************************************************************
    constructor 
*************************************************************************************************************/
Fraction::Fraction()
{
	num		=	0;		// だl
	den		=	1;		// だダ
}



/************************************************************************************************************
    睾c 
*************************************************************************************************************/
Fraction::Fraction( int _n, int _d )
{
    int     __n     =   abs(_n);
    int     __d     =   abs(_d);
	int		gcd		=	GCD( __n, __d );

	num		=	_n / gcd;
	den		=	_d / gcd;

	ckeck_den_positive();		// TOだダOタ计
}



/************************************************************************************************************
    destructor 
*************************************************************************************************************/
Fraction::~Fraction()
{}



/************************************************************************************************************
    copy constructor 
*************************************************************************************************************/
Fraction::Fraction( Fraction &f)
{
	num		=	f.num;
	den		=	f.den;

	ckeck_den_positive();		// TOだダOタ计
}



#if defined(MAC_OS) || defined(LINUX)
/************************************************************************************************************
    copy constructor 
*************************************************************************************************************/
Fraction::Fraction( const Fraction &f)
{
	num		=	f.num;
	den		=	f.den;

	ckeck_den_positive();		// TOだダOタ计
}
#endif




/************************************************************************************************************
    程jそ]计 
*************************************************************************************************************/
int		Fraction::GCD( int a, int b )
{
	int		tmp;

	while( a % b != 0 )
	{
		tmp	=	b;
		b	=	a%b;
		a	=	tmp;
	}

	return	b;
}




/************************************************************************************************************
    锣 
*************************************************************************************************************/
Fraction::operator double ()
{
	return	static_cast<double>(num) / den;
}



/************************************************************************************************************
    荡癸 
*************************************************************************************************************/
int		Fraction::abs( int a )
{
	if( a < 0 )
		a	=	-a;
	return	a;
}




/************************************************************************************************************
    = operator 
*************************************************************************************************************/
Fraction	Fraction::operator = ( Fraction f )
{
	den		=	f.den;
	num		=	f.num;

	ckeck_den_positive();		// TOだダOタ计

	return	*this;
}



/************************************************************************************************************
    TwだダOタ计 
*************************************************************************************************************/
void	Fraction::ckeck_den_positive()
{
	if( den < 0 )
	{
		den		=	-den;
		num		=	-num;
	}
}



/************************************************************************************************************
    锣Θ double A 
*************************************************************************************************************/
double		Fraction::toDouble()
{
	return	static_cast<double>(num) / den;
}


/************************************************************************************************************
    锣Θ float A 
*************************************************************************************************************/
float		Fraction::toFloat()
{
	return	static_cast<float>(num) / den;
}






// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ global function ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/************************************************************************************************************
    << operator 
*************************************************************************************************************/
std::ostream&	operator << ( std::ostream &out, Fraction f )
{
	out << f.num << "/" << f.den << "\n";

	return	out;
}



/************************************************************************************************************
    + operator 
*************************************************************************************************************/
Fraction	operator + ( Fraction a, Fraction b )
{
	Fraction	c;

	int		den	=	a.den * b.den;
	int		num	=	a.num*b.den + a.den*b.num;

	int		_den	=	abs( den );
	int		_num	=	abs( num );
	int		gcd		=	c.GCD( _den, _num );

	den		/=	gcd;
	num		/=	gcd;

	c.den	=	den;
	c.num	=	num;

	c.ckeck_den_positive();		// TOだダOタ计

	return	c;
}




/************************************************************************************************************
    - operator 
*************************************************************************************************************/
Fraction	operator - ( Fraction a, Fraction b )
{
	Fraction	c;

	int		den	=	a.den * b.den;
	int		num	=	a.num*b.den - a.den*b.num;

	int		_den	=	abs( den );
	int		_num	=	abs( num );
	int		gcd		=	c.GCD( _den, _num );

	den		/=	gcd;
	num		/=	gcd;

	c.den	=	den;
	c.num	=	num;

	c.ckeck_den_positive();		// TOだダOタ计

	return	c;
}






/************************************************************************************************************
    * operator 
*************************************************************************************************************/
Fraction	operator * ( Fraction a, Fraction b )
{
	Fraction	c;

	int		den	=	a.den * b.den;
	int		num	=	a.num * b.num;

	int		_den	=	abs( den );
	int		_num	=	abs( num );
	int		gcd		=	c.GCD( _den, _num );

	den		/=	gcd;
	num		/=	gcd;

	c.den	=	den;
	c.num	=	num;

	c.ckeck_den_positive();		// TOだダOタ计

	return	c;
}






/************************************************************************************************************
    / operator 
*************************************************************************************************************/
Fraction	operator / ( Fraction a, Fraction b )
{
	Fraction	c;

	int		den	=	a.den * b.num;
	int		num	=	a.num * b.den;

	int		_den	=	abs( den );
	int		_num	=	abs( num );
	int		gcd		=	c.GCD( _den, _num );

	den		/=	gcd;
	num		/=	gcd;

	c.den	=	den;
	c.num	=	num;

	c.ckeck_den_positive();		// TOだダOタ计

	return	c;
}






}	// end namespace math
}	// end namespace hidog
